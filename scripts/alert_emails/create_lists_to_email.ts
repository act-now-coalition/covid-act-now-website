import _ from 'lodash';
import fs from 'fs-extra';
import path from 'path';
import { GrpcStatus as FirestoreErrorCode } from '@google-cloud/firestore';
import { getFirestore } from './firestore';

function exitWithUsage(): never {
  console.log('Usage: yarn create-lists-to-email alerts.json snapshotId');
  process.exit(1);
}

const readAlertsFile = (alertsFileName: string) => {
  const filePath = path.join(__dirname, alertsFileName);
  const rawData = fs.readFileSync(filePath, 'utf8');
  return JSON.parse(rawData);
};

// Taken from https://ui.dev/validate-email-address-javascript/
const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
const isValidEmail = (email: string): boolean => EMAIL_REGEX.test(email);

/**
 * Takes the alerts file generated by `generate_daily_alerts.ts` and updates the
 * list of emails that we need to send for each location. The steps are:
 *
 * 1. Read the locations that changed threat level from the alerts file.
 * 2. Fetch the emails that are subscribed to the locations that changed threat level.
 * 3. Creates a list of emails for each location and stores them in Firestore.
 *
 * Run the script via yarn:
 *
 *   $ yarn create-lists-to-email alerts.json snapshotId
 */
async function updateSnapshotEmails(
  alertsFileName: string,
  snapshotId: string,
) {
  const db = getFirestore();
  const alertsByLocation = readAlertsFile(alertsFileName);
  const fipsList = Object.keys(alertsByLocation);

  for (const fips of fipsList) {
    const emailQuerySnapshot = await db
      .collection('alerts-subscriptions')
      .where('locations', 'array-contains', fips)
      .get();

    // Remove invalid and repeated emails for the location from the list
    const emailList = _.uniq(
      emailQuerySnapshot.docs
        .map(emailDoc => emailDoc.id)
        .filter(isValidEmail)
        .map(_.toLower),
    );

    try {
      await Promise.all(
        emailList.map(async (email: string) => {
          try {
            await db
              .collection('snapshots')
              .doc(`${snapshotId}/locations/${fips}/emails/${email}`)
              .create({ sentAt: null });
          } catch (updateError) {
            // We don't want to overwrite existing emails for a location to avoid
            // double-sending alerts, in case this is a re-run of the send-alert-emails
            if (updateError.code !== FirestoreErrorCode.ALREADY_EXISTS) {
              throw updateError;
            }
          }
        }),
      );
    } catch (err) {
      console.error(`Error updating emails for location ${fips}`, err);
      process.exit(1);
    }
  }

  console.info(`Done. Updated the emails for ${fipsList.length} locations.`);
}

const main = async () => {
  const args = process.argv.slice(2);
  if (args.length !== 2) {
    exitWithUsage();
  }

  const [alertsFileName, snapshotId] = args;
  await updateSnapshotEmails(alertsFileName, snapshotId);
};

if (require.main === module) {
  main();
}
